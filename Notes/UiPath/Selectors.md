# Selectors

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [Selectors](#selectors)
  - [Introduction to Selectors](#introduction-to-selectors)
      - [What are Selectors?](#what-are-selectors)
      - [Tags and Attributes of Selectors](#tags-and-attributes-of-selectors)
  - [The UI Explorer](#the-ui-explorer)
      - [The UI Frameworks](#the-ui-frameworks)
      - [The Property Explorer](#the-property-explorer)
  - [Types of Selectors](#types-of-selectors)
      - [Full Selectors](#full-selectors)
      - [Partial Selectors](#partial-selectors)
  - [Fine-tuning](#fine-tuning)
  - [Managing Difficult Simulations](#managing-difficult-simulations)
      - [Approaches to difficult simulations](#approaches-to-difficult-simulations)

<!-- /code_chunk_output -->

## Introduction to Selectors
#### What are Selectors?
A Selector is a feature that enables the **Identification** of the UI elements through its **address and attributes** stored as XML fragments. Element Identification is done to perform specific activities in an automation project. They are generated automatically every time we use an activity that interacts with a GUI element.

#### Tags and Attributes of Selectors
Selectors are made up of nodes and each node is made of tags and attributes. Example:
``` xml
 <webctrl parentid='slide-list-container' tag='A' aaname='Details' class='btn-dwnl' />
```
**Tags**
- Nodes in the selector XML fragment
- Correspond to a visual element on the screen
- First node is the app window
- Last node is the element itself
- Examples:
  - wnd (window)
  - html (web page)
  - ctrl (control)
  - webctrl (web page control)
  - java (Java application control)

**Attributes**
- Every attribute has a name and a value
- Only use attribues with constant or known values
- Examples:
  - `parentid='slide-list-container'`
  - `tag='A'`
  - `aaname='Details'`
  - `class='btn-dwnl'`

## The UI Explorer
UI Explorer is the functionality in UIPath that allows analyzing and editing selectors. It contains a status button showing users the sate of the selector, a visual tree panel that displays a navigable UI of each application running at that moment, as well as the selected UI element. It displays all the available tags and attributes and gives the option to check them in or not.

#### The UI Frameworks
| Default | Active Accessibility | UI Automation |
| ------- | -------------------- | ------------- |
| This is the proprietary method which usually works correctly with all types of user interfaces | This represents an earlier solution from Microsoft that makes apps accessible. Recommended for legacy software if default framework does not work as expected | This is improved accessiblity model from Microsoft, which is recommended when using newer applications in case the default framework does not work as expected |

#### The Property Explorer
This is a funcitonality of the UI Explorer that displays all the attribuets of a certain UI element, including those that are not displayed in the selector, like position, visibility, innertext, and so on.
Some use cases are:
- When you want to start an activity after a certain attribute changed its value (using the Wait Attribute Activity)
- When you want to change the value of an attribute ona webpage like its visibility (using Set Attribute Activity)
- When you want to check the state of a certain UI element by checking on an attribute (using the Get Attribute activity)

## Types of Selectors
#### Full Selectors
- Contain all the tags and attributes needed to identify a UI element, including the top-level window
- Generated by the Basic Recorder
- Best suited when the actions performed require switching between multiple windows

#### Partial Selectors
- Don't contain the tags and attributes of the top-level window, thus the activities with partial selectors muyst be enclosed in containers
- Generated by Desktop Recorder
- Best suited for performing multiple actions in the same window

## Fine-tuning
Fine-Tuning is the process of refining selectors in order to have the workflow correctly executed in situations in which the generated selector is unreliable, too specific, or too sensitive with regards to system changes. It mainly conssits of small simple cchanges that have a larger impact on the overall process, such as adding wildcard, using the repair function or using variables in selectors.

Fine-tuning of selectors is required when: 
- **Dynamically generated selectors**: The values of attributes change with each visit
- **Selectors being too specific**: Some selectors are automatically generated with the name of the file or with a value that changes
  - Placeholders are very useful here
- **System Changes**: Some selectors contain the version of the applciation or another element that changes when the application is updated
- **Selectors using IDX**: The IDK is the index of the current elemtn in a container wiht multiple similar elements
  - This might change when a new element appears in the same container

## Managing Difficult Simulations
#### Approaches to difficult simulations
**Anchor Base**
- Useful in cases in which th e attribute values are not reliable,but there is a UI element that is stable and is linked to the target element
- usually has 2 parts: one to locate the anchor UI element, and the second to perform the desired activity

**Relative Selector**
- incorporates the information about the acnhor's selector in the selctor of the target UI element
- New selector will probaly need additional editing, as some nodes of the first selector will still be in the new one
- Solution is to have that part removed and teh selector will stabilize using the anchor's selector

**Visual Tree Hierarchy**
- Hierarchy of the Visual Tree can improve reliability of a selctor by including the tags and attributes of the element that is above in the hierarchy
- Useful when the target element's selector is not reliable, but the immediate parent element is
- The selector will need further editing and validation
  - dynamic part needs to be removed
  - make sure the target element can be identified with a unique attribute

**Find Children**
- Identify all the children of an element that is more stable
- Output is a collection of children
  - need to come up with mechanism to identify only the target UI element (using attributes)