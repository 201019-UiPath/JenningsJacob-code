10/20/2020
	SDK using for project -> .NET core
		includes dotnet CLI, libraries, and runtime

	CLI: common language infrasructure
		can write code in C#, f#, or VB
		all languages have specific compilers:
			c# -> csc
			f# -> fsc
			VB -> vbc
		command to compile code: dotnet build
			code compiled into CIL/MSEL (common intermediate language) (equivalent to JVM in java)
			this makes it platform independant
			has entity called runtime that loads and executes managed assembly code

--------------------------------------------------------------------------------------------------------

	Assembly vs Namespace
		Namespace:
			logically arrange the types (classes) to avoid naming conflicts
		Assembly:
			physical separation of types (classes)
			in the from of .exe or .dll
				exe: executable
					has main method
					actual application
				dll: dynamic linked library
					does not have main method in class
					deployable units

--------------------------------------------------------------------------------------------------------

	CTS: Common Type System
		used by the CLR to enforce strict typing and code verification
		ensures common mapping for types across different languages

	C#		CTS 			VB 			xyz (random new language)
	int 	System.Int32	integer		doo
	short	System.Int16	foo			zoo

	C# -> TypeSafe language, Case sensitive

--------------------------------------------------------------------------------------------------------

Typical Applicaitons layers:
	UI -> user interface
	BL -> business logic
	DB -> database

	Tiers: physical seperation of the layers
	layers: logical seperation of the code

	1-tier applications: all layers contained onto one machine
	2-tier applications: think client-server architecture
	3(N)-tier applications: seperate the UI, BL, and DB into separate servers
		-> complex enterprise level applications

--------------------------------------------------------------------------------------------------------

Solution file:
	collection of projects
	helps logically group code together
		ex: model, tests, business logic, logging, services

	HeroesApp -> Solution		{mkdir <sln name>}
								{dotnet new sln} -> make sure you have sln directory ready

		- UI -> console 		{dotnet new console -o <project name>} 
								{dotnet sln <sln name> add <referebnce to console project>}

		- BL -> class library	{dotnet new classLib -o <project name>}
								{dotnet sln <sln name> add <referebnce to console project>}

		- DL -> class library	{dotnet new classLib -o <project name>}
								{dotnet sln <sln name> add <referebnce to console project>}

		- TEST -> xUnit 		{dotnet new xUnit -o <project name>}
								{dotnet sln <sln name> add <referebnce to console project>}

--------------------------------------------------------------------------------------------------------

C# 
Namespace
	Types
		Members (methods, variables, properties)

data types (classes, enums, structs, interface, delegates):
	all types in C# are inherited directly or indrectly by System.Object
	value types: 
		contains the direct value
		stored in the stack
		fast to access
		ex:
			structs + enums
			predefined: int, long, short, byte, DateTime, Char
	reference types:
		stores reference to that value
		value stored in heap
		expensive to retrieval process
		ex:
			classes + interfaces + delegates
			predefined: string, array, collections

Access Modifiers: change behavior of the types
	Scopes Modifiers: 
		private: only accessible within class
		public: accessible anywhere
		internal: only accessible within assembly
		protected: only accessible within child classes
		protected internal: accessible from current assembly or from child classes
		private protected: accessible from child classes within current assembly

	Default modifiers:
		for class 			 -> internal
		for members of class -> private

Properties: like getters/setters in Java
	smart fields to encapsulate private members

Collections: In memory storage of data
	Arrays: 1-D, 2-D, jagged arrays and multi-dimensional
		drawbacks:
			size of array
			memory inefficient (size must be predefined)
	generics: stack<T>, queue<T>, list<T>, dictionary<TKey, TValue>
		benefits:
			type-safe classes
			memory efficient (don't need to mention size)
